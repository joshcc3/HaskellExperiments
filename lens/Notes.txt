Identical s t a b is a type with the only inhabitant, of type Identical a b a b

Equality s t a b is a witness that s ~ a and b ~ t.
What we mean by a witness is that, if there is a function that can go from
p a (f b) -> p s (f t), forall p and f, it is not possible unless the types are equal.
the existence of such a function implies equality and the function is the witness.

One witness is AnEquality.
We have to define mapEq.
mapEq says: If we have a witness that proves that (s ~ a, b ~ t), then we can perform the substitution s -> a in any context, f i.e. f s -> f a

Thus in order to mapEq, we just substitute a for s in f s which we can only do if the context s ~ a is satisfied, which thus makes it fall right out of substEq.

What fromEq says is, if we have the proof that s ~ a and b ~ t, then we have the proof that b ~ t and s ~ a.

Right, now the big one 'substEq'. What substEq says is that, if we have a proof that s ~ a, and b ~ t then we can create an r that can only be created if this constraint is satified. The challenge with this function is convincing the type checker of the equality using data. This construction, the AnEquality proves it. The reason we get confused with such a thing is that we are assuming this to be forall s t a b. The truth is, this proof will only work when we are  given a valid proof. A valid proof has to have the form (Identical -> Identical) because a proof is only valid if the types of its arguments are inhabitated. 

--------------------------------------------------------------------------------

Isos:

Isos are a subtype of Equality. Hence that is what we are going to build them on.

Apparently, equality is strictly more general than isomorphisms.

iso
This constructs an isomorphism from (s -> a), (b -> t). In category theory the forward and backward mapping, a ~ b, and s ~ t.


from 
Symmetry of an isomorphism. (s -> a) (b -> t) ~ (b -> t) (s -> a)

curried, uncurried simple enum are all familiar ismorphism

au allows us to go from "s" -> "t". that is allow us to express the assumption of the isomorphism (in order to have the back and forth morphism). "a" -> "b" is expressed as Iso s t a b  is isomorphic to Iso b a t s (using from)

auf generalizes au

--------------------------------------------------------------------------------

Lens

Equality allowed us to make no assumptions about the contexts. Thus, the s ~ a, and b ~ t as that was the only way possible to get a morphism between them (the equals ones were in the same contexts).

Iso allowed us to play around with the values contained in the contexts however it was still general enough that a morphism from one to the other meant these objects were indistinguishable based purely on the properties used to define them. Isomorphisms give us the reverse mapping precisely because they must work in any context that allow mapping, thus to provide the mapping there must be the mappings. Profunctors are the essence of mapping and are thus used. the existential quantification is what allows this specific behaviour.

Lenses are not isomorphisms because they break the mapping between random contexts, of the first argument. however a mapping between the b and the t must still be there.

thus the a is tied to the s, the t is tied to the b from the iso. all isos ar still lenses but not all lenses will be isos.

the to mapping is straight forward, the reverse mapping has a dependency on the 's', which means the (s, b) -> t. s -> a.  


--------------------------------------------------------------------------------
Getters further restrict a lens by requiring the functor to be both contravariant covariant. This ensures theat that the functor is independent of the type variables. Making them read-only. The target of the getter is independent of the type of the functor hence we can do nothing except possible view it.
--------------------------------------------------------------------------------
Prisms

Choice class contains
left' :: p a b -> p (Either a c) (Either b c)
right' :: p a b -> p (Either c a) (Either c b)

An applicative is a monoidal functor. That is it a functor from one monoidal category to another. It contains the function (*) that must follow the laws that the monoidal operation must be obeyed. The prism allows us to have choice in what we focus on, that is it can fail. 

A prism allows the target of s to fail

-------------------------------------------------------------------------------- 

All this time we have been and interacting mainly with the s -> a, however the reverse mapping is also present from the profunctor which we can still use. 
THe reverse mapping always suceeds, however the to-mapping may fail.

_Left creates a prism that allows us to view the a or fail giving us the c. 
The relationship between the s and the a is clear cut. The relationship between and t is that of

--------------------------------------------------------------------------------

Traversals are 
